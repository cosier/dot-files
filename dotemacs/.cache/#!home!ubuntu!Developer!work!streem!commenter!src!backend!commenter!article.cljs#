;; Article Namespace
(ns commenter.article
  (:require-macros [cljs.core.async.macros :refer [go]])
  (:require [commenter.database :as db]
            [commenter.logger   :as logger]
            [commenter.stats    :as stats]
            [commenter.http     :as http]
            [cljs.core.async    :as async
             :refer [put! chan <! >! close! alts!]]))


;; Todo: Don't do this.
;; To JSON and back, for compat reasons with clj objects
(defn data-transform [data]
  ;;(println "data-transform: " data)
  (js->clj (JSON/parse (.stringify js/JSON data)) :keywordize-keys true))


;; Callback wrapper
(defn request-handler [data channel]
  (let [[url id] data]
    (fn [err res body]
      (go (>! channel {:url url :articles_id id :body body})))))

;; Makes an actual http request for the data
(defn request-article-html [in-channel out-channel]
  ;; listen for request results
  (go (while true
        (let [[url id] (<! in-channel)]
          (println "articles >> incoming request received: " url "\n")
          (http/request url (request-handler [url id] out-channel))))))

;; Gets the articles from the database and manages the
;; request queue / delegation to the request-article-html function
(defn request-articles [root-channel]
  ;;(println "request-articles")
  (db/latest-articles
   (fn [results]
     (if results (do
     ;; setup article data as well as in/out channels
     ;; for managing the request queue
     (let [articles    (data-transform results)
           in-channel  (chan)
           out-channel (chan)]

       ;; initialise the requester in/out queue
       (request-article-html in-channel out-channel)
       ;;(println "request-article-html channel setup")

       ;; listen for completed requests
       (go (loop [remaining-articles articles]
             ;;(println "Remaining articles to process:" (count remaining-articles))
             ;;(println "Loop")
             (if (= (count remaining-articles) 0)
               (println "articles >> no more remaining articles \n"))

             ;; let scope the url for easier checks
             (let [item (last remaining-articles)
                   url (get item :url)
                   id  (get item :articles_id)]
               ;;(println "sending request" item)
               (if url (>! in-channel [url id])))

             ;; block on results
             (let [ result (<! out-channel) ]
               ;;(println "received result")
               (>! root-channel result))

             (stats/tick-remaining-articles (count remaining-articles))

             ;; determine if we need to go another iteration
             (if (> (count remaining-articles) 0)
               (recur (pop remaining-articles)))
             (if (= (count remaining-articles ) 0)
               (println "articles >> Finished fetching all articles"))))))
         (do
           (println "articles >> db/latest-articles >> no articles found\n")
           (stats/tick-remaining-articles 0)
           (close! root-channel))))))




;; Higher level function for article html reducing
(defn get-html-for-all-articles [borrowed-channel]
  ;;(println "Getting html for all articles")
  (let [article-channel (chan)]
    (request-articles article-channel)
    (go (while true
          (let [data (<! article-channel)]
            ;;(println "Received Article Data" (:url data))
            (if data
              (>! borrowed-channel data)))))))
