<?php

namespace VZA\BidOnTaskBundle\Services;

use VZA\BidOnTaskBundle\Entity\Transaction;
use VZA\BidOnTaskBundle\Entity\UserNotification;
use VZA\BidOnTaskBundle\Entity\AdminNotification;


use Symfony\Component\DependencyInjection\Container;

use PayPal\Common\PPApiContext;
use PayPal\Rest\ApiContext;

use PayPal\Auth\Openid\PPOpenIdSession;
use PayPal\Auth\Openid\PPOpenIdTokeninfo;
use PayPal\Auth\Openid\PPOpenIdUserinfo;
use PayPal\Auth\OAuthTokenCredential;

use PayPal\Api\ExecutePayment;
use PayPal\Api\Payment;
use PayPal\Api\PaymentExecution;


class PaymentService
{
  protected $um;
  protected $container;
  protected $doctrine;
  protected $test_mode;

  protected $config;
  protected $private_access_token;
  // protected $paypal_token_type;

  const PAYPAL_PRODUCTION_URL = "https://api.paypal.com";
  const PAYPAL_SANDBOX_URL = "https://api.sandbox.paypal.com";

  protected $THE_CONFIG = [
    'dev' => [
      'host' => 'https://api.sandbox.paypal.com',
      'openconnect' => 'https://www.sandbox.paypal.com/webapps/auth/protocol/openidconnect',
      ],

    'prod' => [
      'host' => 'https://api.paypal.com',
      'openconnect' => 'https://www.paypal.com/webapps/auth/protocol/openidconnect',
      ],

    'default' => [
      'consent_path' => '/webapps/auth/protocol/openidconnect/v1/authorize',
      'redirect_path' => '/money/connect/confirm',
      ]
  ];

  public function __construct(Container $container, $user_manager)
  {
    $this->um = $user_manager;
    $this->container = $container;

    $this->doctrine = $this->container->get('doctrine');

    $this->test_mode = $this->container->get('vza.settings')->get('paypal_test_mode', 'all');

    if($this->test_mode == 'on'){
      $conf = $this->THE_CONFIG['dev'];
      $env  = 'dev';
    } else {
      $env  = 'prod';
      $conf = $this->THE_CONFIG['prod'];
    }

    $this->env = $env;

    $this->config = array_merge($this->THE_CONFIG['default'], $conf);

    $protocol = 'http://';
    if (isset($_SERVER["HTTPS"]) && $_SERVER["HTTPS"] == "on") {
      $protocol = "https://";
    }

    $this->config['server']    = $protocol . $_SERVER['SERVER_NAME'];
    $this->config['client_id'] = $this->_fetch_client_id($env);
    $this->config['secret']    = $this->_fetch_secret($env);

  }

  public function _create_api_context()
  {


    $this->api_context = new ApiContext(
      new OAuthTokenCredential(
        $this->_fetch_client_id($this->env),
        $this->_fetch_secret($this->env)
      ));


    if($this->env == 'dev'){
      $mode = 'sandbox';
    } else {
      $mode = 'live';
    }

    $this->api_context->setConfig([
      'mode' => $mode,
      'http.ConnectionTimeOut' => 30,
      'log.LogEnabled' => true,
      'log.FileName' => APP_ROOT.'/app/logs/paypal.log',
      'log.LogLevel' => 'FINE'
    ]);


    return $this->api_context;
  }

  public function _create_transaction_payload($data)
  {

    $json = json_encode([
        'intent' => 'sale',
        'payer' => [
          'payment_method' => 'paypal'
        ],
        'transactions' => [
          [
            'item_list' => [
              'items' => [
                [
                  'name'     => $data['title'],
                  'price'    => $data['amount_subtotal'],
                  'quantity' => 1,
                  'currency' => 'CAD'
                ],
              ]
            ],

            'amount' => [
              'total'    => $data['amount_total'],
              'currency' => 'CAD', // todo, dynamic control
              'details'  => [
                'subtotal' => $data['amount_subtotal'],
                'tax'      => $data['amount_tax'],
                'shipping' => 0
              ]
            ],
            'description' => $data['desc']
          ]
        ],
        'redirect_urls' => [
          'return_url' => $data['return_url'],
          'cancel_url' => $data['cancel_url'],
        ]
      ], JSON_PRETTY_PRINT);

      return $json;
  }

  public function _fetch_client_id($env)
  {
      return $this->container->get('vza.settings')->get('paypal_client_id', $env);
  }

  public function _fetch_secret($env)
  {
      return $this->container->get('vza.settings')->get('paypal_secret', $env);
  }

  public function getConnectionInfo()
  {
    return [
      'client_id' => $this->_fetch_client_id($this->env),
      'secret' => $this->_fetch_secret($this->env)
    ];
  }


  /**
   * Handle top to bottom of a PayPal payment for a particular Task
   * @param  \VZA\BidOnTaskBundle\Entity\User $user Person that is going to pay for this sucka
   * @param  \VZA\BidOnTaskBundle\Entity\Task $task Task of said Persons desires...
   * @return HttpResponse       return HttpResponse object back to the calling action
   */
  public function payForTaskFromPaypal($user, $task)
  {

  }

  /**
   * Handle top to bottom of Balance payment for Task
   * including updating the funding status of particular task.
   */
  public function payForTaskFromBalance($user, $task)
  {
      $task_id = $task->getId();

      $mgr = $this->container->get('doctrine')->getManager();


      $tx = $this->createTransaction();

      $tx = new Transaction([
          'debitee'  => $user,
          'amount'   => $task->getAmount(),
          'tx_type'  => Transaction::TX_TYPE_OUTBOUND,
          'task_id'  => $task_id
      ]);

      $mgr->persist($tx);

      if($tx) {
          $task->setIsFunded(true);
          $mgr->persist();
          $message = 'Successfully paid for Task using your Existing BoT Balance';
      }

      $mgr->flush();
      $this->container->get('session')
                      ->getFlashBag()
                      ->add('notice', $message);
      $rurl = '/task/view' . $task_id;
      return new RedirectResponse($rurl);
  }

  public function connectURL()
  {
    $user = $this->container->get('vza.user')->getUser();
    $client_id = $this->config['client_id'];

    $scope = [
        'openid',
        'email',
        'profile',
        'address',
        'https://uri.paypal.com/services/paypalattributes'];
    $redirect_uri = $this->config['server'] . $this->config['redirect_path'];

    $path = '/v1/authorize?client_id=' . $this->config['client_id'] .
      '&response_type=code' .
      '&scope=' . urlencode(implode(' ',$scope)) .
      '&redirect_uri=' . urlencode($redirect_uri);

    $url = $this->config['openconnect'] . $path;
    return $url;

  }

  public function getToken($code)
  {
    $request_code = 0;
    $redirect_uri = $this->config['server'] . $this->config['redirect_path'];
    $params = [
      'client_id' => $this->config['client_id'],
      'client_secret' => $this->config['secret'],
      'code' => $code
    ];


    $postdata =
      'grant_type=authorization_code'.
      '&redirect_uri='. $redirect_uri .
      '&code=' . $code
      ;

    $url   = $this->config['host'] . '/v1/identity/openidconnect/tokenservice';


    // get ACCESS_TOKEN using AUTHORIZATION CODE residing inside the postdata
    $data  = $this->curl($url, [
      'postdata' => $postdata,
      'method' => 'POST',
      ]);

    // invalid response, bail out (most likely session timeout, you have to retry)
    if($data['body'] == null) return false;

    $expires_at = new \DateTime();
    $expires_at->modify('+' . $data['body']['expires_in'] . ' seconds');

    // dump($data);

    $token = [
      'access_token' => $data['body']['access_token'],
      'refresh_token' => $data['body']['refresh_token'],
      'expires_at' => $expires_at,
      ];

    return $token;

    // TODO: remove this for our own straight curl implementation
    // return PPOpenIdTokeninfo::createFromAuthorizationCode($params);
  }

  public function getTokenFromRefresh($refresh_token)
  {
    $request_code = 0;
    $redirect_uri = $this->config['server'] . $this->config['redirect_path'];
    $params = array(
      'client_id' => $this->config['client_id'],
      'client_secret' => $this->config['secret'],
      'code' => $code
    );

    die('get_token_from_refresh: not implemented');

  }

  public function getInfo($access_token)
  {
    $url = $this->config['host'] . '/v1/identity/openidconnect/userinfo/?schema=openid';
    $data = $this->curl($url, ['access_token' => $access_token, 'auth' => false]);
    // dump([$data, $access_token]);
    return $data['body'];
  }

  public function getTransactionsFor($user)
  {
    $txs = $this->container->get('doctrine')
      ->getRepository('BidOnTaskBundle:Transaction')
      ->findBy(['debit_user_id' => $user->getId()], ['created' => 'DESC']);

    return $txs;
  }

  public function getBalanceFor($user)
  {
    $txs = $this->getTransactionsFor($user);
    $bal = 0;
    foreach ($txs as $key => $tx) {
      $tx_type   = $tx->getTxType();
      $tx_status = $tx->getStatus();

      // bail completely on cancelled transactions
      if($tx_status == 'cancelled') continue;

      if( $tx_type == Transaction::TX_TYPE_WITHDRAW ) {
        // has to have some kind of status
        if($tx->isHappening()) $bal -= floatval($tx->getAmount());

      } elseif ( $tx_type == Transaction::TX_TYPE_DEPOSIT ) {
        // has to be finished 100% before crediting
        if($tx->getComplete()) $bal += floatval($tx->getAmount());

      } elseif ( $tx_type == Transaction::TX_TYPE_OUTBOUND ) {
        // proof of existence is enough here
        $bal -= floatval($tx->getAmount());

      } elseif ( $tx_type == Transaction::TX_TYPE_RFEE) {
        $bal -= floatval($tx->getAmount());

      } elseif ( $tx_type == Transaction::TX_TYPE_INBOUND ) {
        // proof of existence is enough here
        $bal += floatval($tx->getAmount());
      }

    }

    return $bal;
  }

  /**
   * Get the PayPal access_token for our own BidOnTask account
   */
  public function getPrivateCredentials()
  {

    $url = $this->config['host'] . '/v1/oauth2/token';

    $auth_response = $this->curl($url, [
      'postdata' => 'grant_type=client_credentials',
      'auth' => true,
      'method' => 'POST',
      ]);

    if($auth_response['body']['access_token']) {
      return $auth_response['body']['access_token'];
    } else {
      dump(['IPC: Private Access Token Expired', $auth_response]);
    }

  }

  /**
   * Executes a paypal paypal using the PayPal API for confirmation.
   * @param  \VZA\BidOnTaskBundle\Entity\Transaction $tx
   * @return [type]
   */
  public function executePayment($tx)
  {

    $payment   = Payment::get($tx->getPaypalTxId(), $this->_create_api_context());
    $execution = new PaymentExecution();
    $execution->setPayerId($tx->getPaypalPayerId());

    try {
      $result = $payment->execute($execution, $this->_create_api_context());
    } catch ( Exception $e) {
      if($this->env == 'dev') dump($e);
      return false;
    }


    if($result){
      return true;
    } else {
      if($this->env == 'dev') dump($result);

      return false;
    }
  }

  /**
   * Sets up a PayPal payment transaction using our own
   * internal Transaction entity for book keeping
   * @param  \VZA\BidOnTaskBundle\Entity\Transaction $tx
   * @param  [Array] $data Allow option overriding
   * @return [type]
   */
  public function createPayment($tx, $data = [])
  {

    $base_url = $_SERVER['HTTP_HOST'];
    $tx_id    = $tx->getId();
    $amount   = $tx->getAmount();

    if($amount < 10) {
      dump($amount);
      $amount = 10;
    }

    $tax_percent = doubleval($this->container->get('vza.settings')
      ->get('paypal_fee_percent')) / 100.00;


    $amount_subtotal  = number_format($amount, 2);
    $amount_tax       = number_format($amount_subtotal * $tax_percent, 2);
    $amount_total     = number_format($amount_subtotal + $amount_tax, 2);

    // merge defaults in
    $data = array_merge([
      'return_url'       => 'http://' . $base_url . '/money/success/' . $tx_id,
      'cancel_url'       => 'http://' . $base_url . '/money/cancel/' . $tx_id,
      'desc'             => 'BidOnTask - Every day tasks and jobs',
      'title'            => 'BidOnTask Payment',
      'amount_total'     => $amount_total,
      'amount_subtotal'  => $amount_subtotal,
      'amount_tax'       => $amount_tax,
    ], $data);

    if(!$tx){
      die('TXID Not provided for payment creation');
    }
    // dump($amount);

    $private_access_token = $this->getPrivateCredentials();
    $payment_create_url   = $this->config['host'] . '/v1/payments/payment';

    $json_payload = $this->_create_transaction_payload($data);

    // make paypal api request using our own access_token as the bearer
    $pp_data = $this->curl($payment_create_url, [
        'method'       => 'POST',
        'postdata'     => $json_payload,
        'access_token' => $private_access_token
      ]);

    if($pp_data['body'] == null || !isset($pp_data['body']['id'])){
      dump($pp_data);
    }

    $paypal_payload = [
      'paypal_tx_id' => $pp_data['body']['id']
    ];

    // grab approval_url & execute_url from the payload
    // will be available in the array using same keys
    foreach ($pp_data['body']['links'] as $key => $value) {
      $rel = str_replace('_url', '', $value['rel']);
      $paypal_payload['paypal_' . $rel  . '_url'] = $value['href'];
    }

    return $paypal_payload;

  }

  public function cancelTransaction($tx)
  {
    $tx->setCancelled(true);
    $tx->setComplete(false);
    $mgr = $this->container->get('doctrine')->getManager();
    $mgr->persist($tx);
    $mgr->flush();

    $msg = 'Your Transaction/Withdrawal has been cancelled';


    $this->container->get('vza.user')->addNotification([
      'type' => UserNotification::TYPE_TX_CANCELLED,
      'link' => '/money',
      'description' => $msg,
      'user' => $tx->getDebitee()
    ]);
  }

  public function restoreTransaction($tx)
  {
    $tx->setCancelled(false);
    $mgr = $this->container->get('doctrine')->getManager();
    $mgr->persist($tx);
    $mgr->flush();
  }

  public function completeTransaction($tx)
  {
    $tx->setComplete(true);
    $mgr = $this->container->get('doctrine')->getManager();
    $mgr->persist($tx);
    $mgr->flush();

    $msg = 'Your Transaction Request has been processed';
    if($tx->getTxType() ==1 ){
      $msg = 'Your Withdrawal Request has been processed';
    }

    $this->container->get('vza.user')->addNotification([
      'type' => UserNotification::TYPE_TX_COMPLETE,
      'link' => '/money',
      'description' => $msg,
      'user' => $tx->getDebitee()
    ]);
  }


  /**
   ** cURL
   **
   ** Handles GET / POST requests for auth requests
   ** @link http://php.net/manual/en/book.curl.php
   **/
  private function curl($url, $opts = []){
    $data = array_merge([
      'auth'         => false,
      'access_token' => false, // most definitely required per reuqest
      'postdata'     => false,
      'method'       => 'GET',
      ], $opts);

    $ch = curl_init($url);


    if ($data['auth'] === true || !$data['access_token']) {
      $headers = ["Accept: application/json", "Accept-Language: en_US"];
      curl_setopt($ch, CURLOPT_HTTPAUTH,       CURLAUTH_BASIC);
      curl_setopt($ch, CURLOPT_USERPWD,        $this->config['client_id'] . ":" . $this->config['secret']);
      curl_setopt($ch, CURLOPT_SSLVERSION,     3);
      curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
      curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);

    } else if($data['access_token']) {
      $headers = [
        // "Content-Type:application/x-www-form-urlencoded",
        "Content-Type:application/json",
        "Authorization:Bearer {$data['access_token']}"
        ];
    }

    $options = array(
      CURLOPT_HTTPHEADER       => $headers,
      CURLOPT_HEADER           => true,
      CURLINFO_HEADER_OUT      => true,
      CURLOPT_RETURNTRANSFER   => true,
      CURLOPT_VERBOSE          => true,
      CURLOPT_TIMEOUT          => 10
    );


    if ($data['method'] == 'POST') {
      $options[CURLOPT_POSTFIELDS]    = $data['postdata'];
      $options[CURLOPT_CUSTOMREQUEST] = $data['method'];
    }

    curl_setopt_array($ch, $options);

    $response = curl_exec($ch);
    $header   = substr($response, 0, curl_getinfo($ch, CURLINFO_HEADER_SIZE));
    $body     = json_decode(substr($response, curl_getinfo($ch, CURLINFO_HEADER_SIZE)), true);


    curl_close($ch);

    return [ 'header' => $header, 'body' => $body ];
  }




}
